all_zipcodes for plotting
========================================================

Get the all_zipcodes data. 
Get ready the shaoefiles to draw them wth ggplot2.


0. wd and libraries
```{r}
setwd("/Users/martinez/Dropbox/R InnovaChallengeBBVA")
library(rgeos)
library(maptools)
library(sp)
library(rgdal)
library(Hmisc) #for building the curves
library(ggplot2)
```


1. Read the data

```{r read_the_data}
all_zipcodes <- read.csv("rawdata/all_zipcodes.csv", header = TRUE, colClasses = "character")

# Switch the variable to the right class
all_zipcodes$num_cards <- as.integer(all_zipcodes$num_cards)
all_zipcodes$num_payments <- as.integer(all_zipcodes$num_payments)
all_zipcodes$incomes <- as.numeric(all_zipcodes$incomes)
								   
# Load the metadata
dates <- read.csv("metadata/dates.csv", stringsAsFactors = FALSE)
postal_codes <- read.csv("metadata/postal_codes.csv", stringsAsFactors = FALSE)
categories <- read.csv("metadata/merchants_categories.csv", stringsAsFactors = FALSE) 
```

2. Subset only the rows where the origon cp is in Madrid Capital.

```{r subset_cp_origin_Madrid}
all_zipcodes_mad <- all_zipcodes[all_zipcodes$cp_origin %in% postal_codes$label, ]
```

3. Sum per month (to see the whole period, selection by month won't be possible)
```{r aggregate_month_and_cp_origin}
# Aggregate by month

no_month <- all_zipcodes_mad

no_month <- aggregate(cbind(num_cards, num_payments, incomes) ~ cp_origin + cp_dest + category, data = no_month, sum)
```


4. Add a incomes percentage column. 
> For every category
> For every cp_origin
> Calculate the percentages

```{r incomes_percentages}
expenditure <- no_month
options(stringsAsFactors = FALSE)
expenditure_per <- data.frame()

for (cat in categories$code){
	exp_cat <- expenditure[expenditure$category == cat, ]
	for (cp in postal_codes$label){
		exp_cat_cp <- exp_cat[exp_cat$cp_origin == cp, ]
		exp_cat_cp$incomes_per <- round(prop.table(exp_cat_cp$incomes)*100, digits = 2)
		expenditure_per <- rbind(expenditure_per, exp_cat_cp)
	}
}

# test
length(expenditure_per$cp_origin)
length(expenditure$cp_origin)
```

5. Add 'comercios' column

> Take the matrix cp and num comercios from the poly data
> add to every cp_dest the correspondant number of 'comercios'


```{r comercios_column}

# Get in which 'cp_poly_mad' polygons fall the 'comerciales' points and name them as 'comercial'

poly_comerciales <- over(as(comerciales, "SpatialPoints"), as(cp_poly_mad, "SpatialPolygons")) # needs to be 'SpatialPoints' and 'SpatialPolygons' class

poly_comerciales
# NA indicates that the point does not fall in any polygon.
# The number indicates the is the index (number) of the polygon in which a point falls (these will be the 'comerciales')

poly_comerciales <- poly_comerciales-1 # The id's in cp_poly_mad start in 0.

## numero de comercios para cada id
freq <- as.data.frame(table(poly_comerciales), stringsAsFactors = FALSE)
freq
# length = 39 indicates that there are 39 polygons with at least one comerce

# merge the freq with the cp_poly_mad@data 
cp_poly_mad$id <- row.names(cp_poly_mad@data)
colnames(freq)[names(freq) == "poly_comerciales"] <- "id"


cp_poly_mad@data <- merge(cp_poly_mad@data, freq, all = TRUE)
cp_poly_mad$Freq[is.na(cp_poly_mad$Freq)] <- 0
cp_poly_mad$commercial <- cut(cp_poly_mad$Freq, 
								 breaks = c(0, 1, 4, 7, 10,Inf), 
								 labels = c("0 stores", "1 - 3 stores", "4 - 6 stores", "7 - 10 stores", "11 stores"), 
								 right = FALSE)

cp_poly_mad@data <- cp_poly_mad@data[order(cp_poly_mad$GEOCODIGO, decreasing = FALSE), ]


# subset the cp_poly_mad@data cp to get the 'num_comercios' matrix
n_comercios <- subset(cp_poly_mad@data, select = c(GEOCODIGO, Freq))

# Assign them to the correspondant cp_dest in the expenditure_per df
colnames(n_comercios)[names(n_comercios) == "GEOCODIGO"] <- "cp_dest"

expenditure_per <- merge(expenditure_per, n_comercios)

```

6. Add origin(lon, lat) and dest (long lat) columns (4 new columns required)

```{r add_origin_dest_lon_lat}
# Get the centroids of every polygon

coord <- as.data.frame(coordinates(cp_poly_mad))

colnames(coord) <- c("lon", "lat")
coord$id <- row.names(coord)

centroids <- merge(cp_poly_mad@data[ ,c(1,3)], coord, by = "id")

colnames(centroids) <- c("id", "cp_origin","lon_origin", "lat_origin")
expenditure_per_origin <- merge(expenditure_per, centroids, by = "cp_origin")

colnames(centroids) <- c("id", "cp_dest","lon_dest", "lat_dest")
expenditure_per <- merge(expenditure_per_origin, centroids[ ,c(2:4)], by = "cp_dest")

write.csv(expenditure_per, "metadata/expenditure_per.csv", row.names = FALSE)
```



9. To build the lines between two points


```{r building_curves}

expenditure_per <- read.csv("metadata/expenditure_per.csv", stringsAsFactors = FALSE, header = TRUE)

# Function to draw the curves

path <- function(x1, y1, x2, y2, len = 100, curved = TRUE){
	from <- c(x1, y1) # Origin
	to <- c(x2, y2)  # Terminus
	
	# Add curve:
	bezierMid <- c(from[1], to[2])  # A midpoint, for bended edges
	bezierMid <- (from + to + bezierMid) / 3  # Moderate the Bezier midpoint
	
	if(curved == FALSE){bezierMid <- (from + to) / 2}  # Remove the curve
	
	edge <- data.frame(bezier(c(from[1], bezierMid[1], to[1]),  # Generate
							  c(from[2], bezierMid[2], to[2]),  # X & y
							  evaluation = len))  # Bezier path coordinates
	return(edge)
}
```


10. Fortify the cp_poly_mad (with the Freq added)
```{r fortify_polygons} 

data_cpPolyMad <- fortify(cp_poly_mad, region = "id")

data_cpPolyMad <- merge(data_cpPolyMad, cp_poly_mad@data, by = "id") 
str(data_cpPolyMad)
data_cpPolyMad$commercial <- as.character(data_cpPolyMad$commercial)
```













11. Plot with the cuves
```{r plot_polys_and_curves}
# get the cp labels
cp_labels <- subset(expenditure_per,select = c("cp_origin", "lon_origin", "lat_origin" ))
cp_labels <- cp_labels[!duplicated(cp_labels), ]

# subset the type of polygons to plot them in diferent colors

poly_data <- data_cpPolyMad[data_cpPolyMad$GEOCODIGO == 28010, ]

poly_in <- unique(curves$cp[curves$cp != 28002])
poly_in_data <- data_cpPolyMad[data_cpPolyMad$GEOCODIGO %in% poly_in, ]

poly_out <- unique(curves$cp)
poly_out_data <- data_cpPolyMad[!(data_cpPolyMad$GEOCODIGO %in% poly_out), ]


#plot them

jpeg(paste("graphs/map_", "cp", "_", "cat", ".jpeg", sep = ""), width = 3000, height=3000)


ggplot()+
geom_polygon(data=poly_out_data, aes(x=long, y=lat, group=group), colour= "white", fill = "grey", lwd=0.5, alpha = 0.8)+
	
geom_polygon(data=poly_in_data, aes(x=long, y=lat, group=group, fill = Freq), colour= "white", lwd=0.5, alpha = 0.8) +

	
geom_polygon(data=poly_data, aes(x=long, y=lat, group=group), colour= "white", fill = "red", lwd=0.5, alpha = 0.8) +

geom_path(data = curves[curves$cp != 28010, ], aes(x = x, y = y, group = group, size = income_per, colour = factor(Freq)), lineend = "round", arrow = arrow()) +
scale_colour_brewer(type="seq", palette=3) + 
	
geom_text(data=cp_labels, aes(lon_origin, lat_origin, label = cp_origin), size=5)
dev.off()

```

```{r}




png("exploratory_graphs/cp_labels.png", width = 3000, height=3000)
ggplot()+
geom_polygon(data=test, aes(x=long, y=lat, group=group, fill = GEOCODIGO), colour= "white", lwd=0.5, alpha = 0.8)
+
geom_text(data=cp_labels, aes(lon_origin, lat_origin, label = cp_origin), size=2)
dev.off()

cpa <- c(28013, 28048, 28010)

test <- data_cpPolyMad[data_cpPolyMad$GEOCODIGO %in% cpa, ]
```







getContiguous <- function(mainCP){
	contiguous <- data.frame()
	mainCP <- as.numeric(mainCP)
	for (cp in postal_codes$label){
		print(mainCP)
		print(cp)
		intersec <- gIntersection(as(cp_poly_mad[cp_poly_mad$GEOCODIGO == mainCP, ], "SpatialPolygons"), as(cp_poly_mad[cp_poly_mad$GEOCODIGO == cp, ], "SpatialPolygons"))
		if(length(intersec) != 0 & cp != mainCP){
			tempContiguos <- data.frame(
				"mainCP" = mainCP,
				"contiguousCP" = cp)
			contiguous <- rbind(contiguous, tempContiguos)
		}
	}
	return(contiguous)
}

```






Pintar del "cp_origin" al cp_dest lineas con grosor según incomes_per.
> Cargar las shapefiles de los polígonos de los cp.
> dibujar una linea de un punto a otro

```{r plot_lines_seguir_aqui}

plot(cp_poly_mad, col = cp_poly_mad$colors) # Shapefile from 02_ICBBVA_calles comerciales

# get the centroids for the polys

# add the to the expenditure df as variables: cp_origin_lon, cp_origin_lat, cp_dest_long, cp_dest_lat (maybe frotify them and merge to the expenditure data frame) this before the subsettiong so I will do it only once.
# consider this as origin and end, excep for the cp_origin itself, by adding 1(or any appropiate constant) to the end lon and lat



# the cp_origin in the function
origin_lon = coordinates(cp_poly_mad[cp_poly_mad$GEOCODIGO == 28013, ])[ ,1]
origin_lat = coordinates(cp_poly_mad[cp_poly_mad$GEOCODIGO == 28013, ])[ ,2]

# for every cp_dest in the 'expenditure_subset' df 28002, to have ome origin point and multiples dest points
dest_lon = coordinates(cp_poly_mad[cp_poly_mad$GEOCODIGO == 28002, ])[ ,1]
dest_lat = coordinates(cp_poly_mad[cp_poly_mad$GEOCODIGO == 28002, ])[ ,2]



# consider the percentaje the line width. If the resultants lines are very thick, divide the percentage by 2 or another appropiate constant

# one curve for each cp_dest

# fortyfi the polygons, and add this annotation text to the gg plot.



png("exploratory_graphs/comercial_cp.png", width = 2000, height = 2000)
plot(cp_poly_mad, col = cp_poly_mad$colors)
plot(comerciales, pch= 4, cex = 5, col = "green", add = TRUE)
pointLabel(cents[ ,1], cents[ ,2], labels=cp_poly_mad$DESBDT)
lines(points, col='red')
dev.off()
```

Try this in ggplot
Imagino que en ggplot será hacer un df, en el que esté origin y end de la lon y la lat y asociado, el porcentage de incomes para que pinte el grosor por ahí.

luego hay que hacerlas curvas...
```{r ggplot}
dest <- as.data.frame(cbind(dest_lon, dest_lat))
origin <- as.data.frame(cbind(origin_lon, origin_lat))
a <- cbind(origin, dest)

ggplot() +
	geom_segment(aes(x = origin_lon, y = origin_lat, xend = dest_lon, yend = dest_lat), data = a)
   

line_width <- porcentaje/2


	

ggplot()
```




Luego, con este df, identificar el propio cp, los cps comerciales(y grado de comercio) y los cp_adyacentes para el gráfico de barras
